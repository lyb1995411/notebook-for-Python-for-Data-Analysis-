# 第11章 时间序列
## 11.1 日期和时间数据的类型及工具
`datetime`、`time`、`calendar`模块是处理时间数据的主要内容。其中，使用最广泛的是`datetime.datetime`类型。

`datetime`存储的时间能细化到微妙：


```python
from datetime import datetime
now=datetime.now()
print(now)
# datetime.datetime(2020, 5, 26, 11, 32, 9, 838373)
print(now.year,now.month,now.day)
# (2020, 5, 26)
```

`timedelta`表示两个`datetime`对象的时间差。`timedelta(x,y)`其中`x`表示天数，`y`表示秒数：


```python
delta = datetime(2011, 1, 7) - datetime(2008, 6, 24, 8, 15)
print(delta)
# datetime.timedelta(days=926, seconds=56700)
print(delta.days)
# 926
print(delta.seconds)
# 56700
```

可以对`datetime`对象加上或减去一个`timedelta`或其整数倍来产生一个新的`datetime`对象


```python
from datetime import timedelta
start = datetime(2011, 1, 7)
print(start + timedelta(12))  #加上12天
# datetime.datetime(2011, 1, 19, 0, 0)
print(start - 2 * timedelta(12))  #减去24天
# datetime.datetime(2010, 12, 14, 0, 0)
```

表11-1 datetime模块中的数据类型

![](assets\表11-1 datetime模块中的数据类型.png)

### 11.1.1 字符串与`datetime`互相转换

对于一个已知的`datetime`对象，你可以使用`str`或者指定格式的`strftime`对其进行格式化：


```python
stamp = datetime(2011, 1, 3)
print(str(stamp))
# '2011-01-03 00:00:00'
print(stamp.strftime('%Y-%m-%d'))
# '2011-01-03'
```

表11-2列出了全部的格式化编码。

表11-2 datetime格式定义（兼容ISO C89）

<img src="assets\表11-2 datetime格式定义.png" style="zoom:70%;" />

同理，已知一个字符串时，你也可以将其转换为日期：(1)`strptime`  (2)`parser.parse`


```python
value = '2011-01-03'
print(datetime.strptime(value, '%Y-%m-%d'))
# datetime.datetime(2011, 1, 3, 0, 0)

datestrs = ['7/6/2011', '8/6/2011']
print([datetime.strptime(x, '%m/%d/%Y') for x in datestrs])
# [datetime.datetime(2011, 7, 6, 0, 0), datetime.datetime(2011, 8, 6, 0, 0)]
```

`datetime.strptime`是在已知格式下转化日期的好方法，但是每次都编写一个日期格式比较麻烦。简便方法是使用第三方`dateutil`包中的`parser.parse`方法（这个包已经在pandas中了）


```python
from dateutil.parser import parse
print(parse('2011-01-03'))
# datetime.datetime(2011, 1, 3, 0, 0)
```

`dateutil`还可以解析大部分人类可理解的日期表示：


```python
print(parse('Jan 31, 1997 10:45 PM')
# datetime.datetime(1997, 1, 31, 22, 45)
```

国际场合下，日期出现在月份之前很常见，为了避免混淆，可以传递`dayfirst=True`来表明这种情况：


```python
print(parse('1/8/1995'))   #未声明时
# datetime.datetime(1995, 1, 8, 0, 0)
print(parse('1/8/1995',dayfirst=True))   #声明后
# datetime.datetime(1995, 8, 1, 0, 0)
```

`to_datetime`方法可以解析多种不同的日期表示形式。对标准日期格式（如ISO8601）的解析非常快：

```python
datestrs = ['2011-07-06 12:00:00', '2011-08-06 00:00:00']
print(pd.to_datetime(datestrs))
# DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00'], dtype='datetime64[ns]', freq=None)
```

它还可以处理缺失值（`None`、空字符串等）：

```python
idx = pd.to_datetime(datestrs + [None])
print(idx)
# DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00', 'NaT'], dtype='datetime64[ns]', freq=None)
print(idx[2])
# NaT
print(pd.isnull(idx))
# array([False, False,  True])
```

表11-3 特定于当前环境的日期格式

![](assets\表11-3 特定于当前环境的日期格式.png)

`dateutil.parser`是一个有用但并不完美的工具，有时他会将一些字符串识别为错误的日期。

## 11.2 时间序列基础


```python
from datetime import datetime
dates = [datetime(2011, 1, 2), datetime(2011, 1, 5),
         datetime(2011, 1, 7), datetime(2011, 1, 8),
         datetime(2011, 1, 10), datetime(2011, 1, 12)]
ts = pd.Series(np.random.randn(6), index=dates)
print(ts)
# 2011-01-02    0.092908
# 2011-01-05    0.281746
# 2011-01-07    0.769023
# 2011-01-08    1.246435
# 2011-01-10    1.007189
# 2011-01-12   -1.296221
# dtype: float64

print(ts.index)
# DatetimeIndex(['2011-01-02', '2011-01-05', '2011-01-07', '2011-01-08',
#                '2011-01-10', '2011-01-12'],
#               dtype='datetime64[ns]', freq=None)

print(ts.index.dtype)
# dtype('<M8[ns]')

print(ts + ts[::2])
# 2011-01-02    0.185816
# 2011-01-05         NaN
# 2011-01-07    1.538045
# 2011-01-08         NaN
# 2011-01-10    2.014379
# 2011-01-12         NaN
# dtype: float64

stamp = ts.index[0]
print(stamp)
# Timestamp('2011-01-02 00:00:00')
```

### 11.2.1 索引、选择、子集
从时间序列中基于标签进行索引时，其行为和其它的pandas.Series类似：


```python
stamp = ts.index[2]
print(ts[stamp])
# 0.7690225676118387
```

为了简便，还可以直接传递能解释为日期的字符串进行索引：


```python
print(ts['1/10/2011'])
# 1.0071893575830049
print(ts['20110110'])
# 1.0071893575830049
```

同理，对于较长的时间序列，可以通过传递一个年份或月份轻松的对其进行索引：


```python
longer_ts = pd.Series(np.random.randn(1000),index=pd.date_range('1/1/2000',periods=1000))
###传递年份
print(longer_ts)
# 2000-01-01    0.274992
# 2000-01-02    0.228913
# 2000-01-03    1.352917
# 2000-01-04    0.886429
# 2000-01-05   -2.001637
#                 ...   
# 2002-09-22   -0.178098
# 2002-09-23    2.122315
# 2002-09-24    0.061192
# 2002-09-25    0.884111
# 2002-09-26   -0.608506
# Freq: D, Length: 1000, dtype: float64

print(longer_ts['2001'])
# 2001-01-01   -0.171724
# 2001-01-02   -0.827840
# 2001-01-03    0.370548
# 2001-01-04   -0.674167
# 2001-01-05   -1.712340
#                 ...   
# 2001-12-27   -0.880247
# 2001-12-28   -0.376872
# 2001-12-29   -1.157682
# 2001-12-30   -0.125632
# 2001-12-31   -1.402235
# Freq: D, Length: 365, dtype: float64

### 传递年月
print(longer_ts['2001-05'])
# 2001-05-01    0.251343
# 2001-05-02    1.624623
# 2001-05-03   -0.240567
# 2001-05-04    0.163052
# 2001-05-05   -0.586669
#                 ...   
# 2001-05-27    0.272924
# 2001-05-28   -0.601544
# 2001-05-29    0.574265
# 2001-05-30   -0.194115
# 2001-05-31    0.202225
# Freq: D, Length: 31, dtype: float64
```

使用`datatime`对象切片

```python
print(ts)
# 2011-01-02    0.092908
# 2011-01-05    0.281746
# 2011-01-07    0.769023
# 2011-01-08    1.246435
# 2011-01-10    1.007189
# 2011-01-12   -1.296221
# dtype: float64

print(ts[datetime(2011, 1, 7):])
# 2011-01-07    0.769023
# 2011-01-08    1.246435
# 2011-01-10    1.007189
# 2011-01-12   -1.296221
# dtype: float64

### 查询时不一定只能输入序列中存在的时间，也可以使用不包含在序列中的时间戳进行切片
print(ts['1/6/2011':'1/11/2011'])
# 2011-01-07    0.769023
# 2011-01-08    1.246435
# 2011-01-10    1.007189
# dtype: float64

### 上述例子还有一个等价方法 truncate,自己设定一个截止日期after，查询操作将从序列开头查询至after
print(ts.truncate(after='1/9/2011'))
# 2011-01-02    0.092908
# 2011-01-05    0.281746
# 2011-01-07    0.769023
# 2011-01-08    1.246435
# dtype: float64
```

以上操作皆适用于`dataframe`

```python
dates = pd.date_range('1/1/2000', periods=100, freq='W-WED')
long_df = pd.DataFrame(np.random.randn(100, 4),
                       index=dates,
                       columns=['Colorado', 'Texas',
                                'New York', 'Ohio'])
print(long_df.loc['5-2001'])
# 	             Colorado	    Texas	 New York	     Ohio
# 2001-05-02	 0.035787	 1.034372	-0.506926	 1.228659
# 2001-05-09    -1.079650	-1.503665	-0.167360	-0.183889
# 2001-05-16	-1.003073	-0.292718	-0.830605	-0.271502
# 2001-05-23	 0.825583	 1.121559	 0.492013	 0.759003
# 2001-05-30	-0.442164	 1.284845	 0.801260	 1.025196
```

### 11.2.2 含有重复索引的时间序列
某些时候，可能有多个观察值落在特定的时间戳上，例如：


```python
dates = pd.DatetimeIndex(['1/1/2000', '1/2/2000', '1/2/2000',
                          '1/2/2000', '1/3/2000'])
dup_ts = pd.Series(np.arange(5), index=dates)
print(dup_ts)
# 2000-01-01    0
# 2000-01-02    1
# 2000-01-02    2
# 2000-01-02    3
# 2000-01-03    4
# dtype: int32
```

检查序列的索引是否唯一


```python
print(dup_ts.index.is_unique)
# False 
```

当你查询含有重复时间戳的索引时，会出现多个结果：


```python
print(dup_ts['1/3/2000'])  # not duplicated
# 4
print(dup_ts['1/2/2000'])  # duplicated
# 2000-01-02    1
# 2000-01-02    2
# 2000-01-02    3
# dtype: int32 
```

如果你想把含有多个时间戳的时间数据聚合起来，比如将本例中`2000-01-02`日的两个数据合并为一组，


```python
### 可以使用之前所学的groupby方法，并传递level=0
grouped = dup_ts.groupby(level=0)
print(grouped.mean())
# 2000-01-01    0
# 2000-01-02    2
# 2000-01-03    4
# dtype: int32

print(grouped.count())
# 2000-01-01    1
# 2000-01-02    3
# 2000-01-03    1
# dtype: int64
```

## 11.3 日期范围、频率和移位
Pandas的通用时间序列是不规则的，这已经能满足大多数应用场景。但是，若想处理固定频率的场景，例如每日、每月、每15分钟，这就意味着我们可能需要向时间序列中引入缺失值。

幸运的是，Pandas功能强大，拥有一整套标准工具用于**计算轴向重采样**、**推断频率**以及**生成固定频率**的数据范围。

```python
print(ts)
# 2011-01-02    0.092908
# 2011-01-05    0.281746
# 2011-01-07    0.769023
# 2011-01-08    1.246435
# 2011-01-10    1.007189
# 2011-01-12   -1.296221
# dtype: float64
resampler = ts.resample('D')
```

字符串“D”是每天的意思。

### 11.3.1 生成日期范围
`pandas.date_range`是用于根据特定频率生成指定长度的`DatetimeIndex`

默认情况下，在特定范围内，`date_range`生成的是范围内每日时间戳；

但是如果你只传递一个起始日期或截止日期，那么还需要传递一个用于生成范围（`periods`参数）的数字，即数字是几就生成几个时间戳


```python
index = pd.date_range('2012-04-01', '2012-06-01')
print(index)
# DatetimeIndex(['2012-04-01', '2012-04-02', '2012-04-03', '2012-04-04',
#                '2012-04-05', '2012-04-06', '2012-04-07', '2012-04-08',
#                '2012-04-09', '2012-04-10', '2012-04-11', '2012-04-12',
#                '2012-04-13', '2012-04-14', '2012-04-15', '2012-04-16',
#                '2012-04-17', '2012-04-18', '2012-04-19', '2012-04-20',
#                '2012-04-21', '2012-04-22', '2012-04-23', '2012-04-24',
#                '2012-04-25', '2012-04-26', '2012-04-27', '2012-04-28',
#                '2012-04-29', '2012-04-30', '2012-05-01', '2012-05-02',
#                '2012-05-03', '2012-05-04', '2012-05-05', '2012-05-06',
#                '2012-05-07', '2012-05-08', '2012-05-09', '2012-05-10',
#                '2012-05-11', '2012-05-12', '2012-05-13', '2012-05-14',
#                '2012-05-15', '2012-05-16', '2012-05-17', '2012-05-18',
#                '2012-05-19', '2012-05-20', '2012-05-21', '2012-05-22',
#                '2012-05-23', '2012-05-24', '2012-05-25', '2012-05-26',
#                '2012-05-27', '2012-05-28', '2012-05-29', '2012-05-30',
#                '2012-05-31', '2012-06-01'],
#               dtype='datetime64[ns]', freq='D')
```

即给定范围，又指定生成个数时，结果是按长度比例生成的时间戳


```python
print(pd.date_range(start='2012-04-01', periods=20))
# DatetimeIndex(['2012-04-01', '2012-04-02', '2012-04-03', '2012-04-04',
#                '2012-04-05', '2012-04-06', '2012-04-07', '2012-04-08',
#                '2012-04-09', '2012-04-10', '2012-04-11', '2012-04-12',
#                '2012-04-13', '2012-04-14', '2012-04-15', '2012-04-16',
#                '2012-04-17', '2012-04-18', '2012-04-19', '2012-04-20'],
#               dtype='datetime64[ns]', freq='D')

print(pd.date_range(end='2012-06-01', periods=20))
# DatetimeIndex(['2012-05-13', '2012-05-14', '2012-05-15', '2012-05-16',
#                '2012-05-17', '2012-05-18', '2012-05-19', '2012-05-20',
#                '2012-05-21', '2012-05-22', '2012-05-23', '2012-05-24',
#                '2012-05-25', '2012-05-26', '2012-05-27', '2012-05-28',
#                '2012-05-29', '2012-05-30', '2012-05-31', '2012-06-01'],
#               dtype='datetime64[ns]', freq='D')
```

除了传递起止时间、生成个数之外。你还可以通过传递频率参数freq，来决定生成时间序列的频率。例如：


```python
### ‘BM’代表 business end of month 工作日的月底日期，表11-4给出全部的频率列表
print(pd.date_range('2000-01-01', '2000-12-01', freq='BM'))
# DatetimeIndex(['2000-01-31', '2000-02-29', '2000-03-31', '2000-04-28',
#                '2000-05-31', '2000-06-30', '2000-07-31', '2000-08-31',
#                '2000-09-29', '2000-10-31', '2000-11-30'],
#               dtype='datetime64[ns]', freq='BM')
```

表11-4 基本的时间序列频率

![](assets\表11-4 基本的时间序列频率.png)

有些时候，起止日期会精确到小时分钟，但是我们只想要日期，这时可以使用`normalize`对其进行标准化：


```python
### 标准化前
print(pd.date_range('2012-05-02 12:56:31', periods=5))
# DatetimeIndex(['2012-05-02 12:56:31', '2012-05-03 12:56:31',
#                '2012-05-04 12:56:31', '2012-05-05 12:56:31',
#                '2012-05-06 12:56:31'],
#               dtype='datetime64[ns]', freq='D'# 

### 标准化后
print(pd.date_range('2012-05-02 12:56:31', periods=5, normalize=True))
# DatetimeIndex(['2012-05-02', '2012-05-03', '2012-05-04', '2012-05-05',
#                '2012-05-06'],
#               dtype='datetime64[ns]', freq='D')
```

### 11.3.2 频率和日期偏置
Pandas中的频率是由基础频率和倍数组成的。例如：


```python
from pandas.tseries.offsets import Hour, Minute
hour = Hour()
print(hour)
# <Hour>
```

定义一个整数来定义偏置量的倍数


```python
four_hours = Hour(4)
print(four_hours)
# <4 * Hours>
```

通常使用中，只需要在基础频率前面放置倍数


```python
print(pd.date_range('2000-01-01', '2000-01-03 23:59', freq='4h'))
# DatetimeIndex(['2000-01-01 00:00:00', '2000-01-01 04:00:00',
#                '2000-01-01 08:00:00', '2000-01-01 12:00:00',
#                '2000-01-01 16:00:00', '2000-01-01 20:00:00',
#                '2000-01-02 00:00:00', '2000-01-02 04:00:00',
#                '2000-01-02 08:00:00', '2000-01-02 12:00:00',
#                '2000-01-02 16:00:00', '2000-01-02 20:00:00',
#                '2000-01-03 00:00:00', '2000-01-03 04:00:00',
#                '2000-01-03 08:00:00', '2000-01-03 12:00:00',
#                '2000-01-03 16:00:00', '2000-01-03 20:00:00'],
#               dtype='datetime64[ns]', freq='4H')
```

多个偏置通过加法联合


```python
print(Hour(2) + Minute(30))
# <150 * Minutes>
```

也可传递频率字符串，如`1h30min`


```python
print(pd.date_range('2000-01-01', periods=10, freq='1h30min'))
# DatetimeIndex(['2000-01-01 00:00:00', '2000-01-01 01:30:00',
#                '2000-01-01 03:00:00', '2000-01-01 04:30:00',
#                '2000-01-01 06:00:00', '2000-01-01 07:30:00',
#                '2000-01-01 09:00:00', '2000-01-01 10:30:00',
#                '2000-01-01 12:00:00', '2000-01-01 13:30:00'],
#               dtype='datetime64[ns]', freq='90T')
```

#### 11.3.2.1 月中某星期的日期

月中某星期的日期`(week of month)`是一个非常有用的频率。例如你可以获取每月第三个星期五这样的日期：


```python
rng = pd.date_range('2012-01-01', '2012-09-01', freq='WOM-3FRI')
print(list(rng))
# [Timestamp('2012-01-20 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-02-17 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-03-16 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-04-20 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-05-18 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-06-15 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-07-20 00:00:00', freq='WOM-3FRI'),
#  Timestamp('2012-08-17 00:00:00', freq='WOM-3FRI')]
```

### 13.3.3 移位（前向和后向）日期
“移位”是指将数据向前或向后移动，而不改变索引。Series和DataFrame中的shift方法即可实现移位：


```python
ts = pd.Series(np.random.randn(4),
               index=pd.date_range('1/1/2000', periods=4, freq='M'))
print(ts)
# 2000-01-31   -1.386823
# 2000-02-29   -0.181085
# 2000-03-31   -0.658086
# 2000-04-30    0.476751
# Freq: M, dtype: float64

## 前移2个
print(ts.shift(2))
# 2000-01-31         NaN
# 2000-02-29         NaN
# 2000-03-31   -0.160366
# 2000-04-30   -1.522472
# Freq: M, dtype: float64

## 后移两个
print(ts.shift(-2))
# 2000-01-31    1.173413
# 2000-02-29    0.839666
# 2000-03-31         NaN
# 2000-04-30         NaN
# Freq: M, dtype: float64
```

可以看出，简单的`shift`移动后，时间序列的起始位或结束位引入了缺失值，一些数据被丢弃了

实际上，在频率已知的情况下，我们可以将频率也传递给`shift`来推移时间戳，而不是简单的数据：


```python
print(ts.shift(2,freq='M'))
# 2000-03-31    2.319066
# 2000-04-30    1.188635
# 2000-05-31    1.173413
# 2000-06-30    0.839666
# Freq: M, dtype: float64
```

其他的频率也可以传递

```python
print(ts.shift(3, freq='D'))
# 2000-02-03    2.319066
# 2000-03-03    1.188635
# 2000-04-03    1.173413
# 2000-05-03    0.839666
# dtype: float64

print(ts.shift(1, freq='90T'))
# 2000-01-31 01:30:00    2.319066
# 2000-02-29 01:30:00    1.188635
# 2000-03-31 01:30:00    1.173413
# 2000-04-30 01:30:00    0.839666
# Freq: M, dtype: float64
```

由上可以看出，原本空缺值的索引不见了，而是向着移位方向按给定频率生成新的索引，充分利用了原始数据。

#### 11.3.3.1 使用偏置进行移位日期

pandas的日期偏移量还可以用在`datetime`或`Timestamp`对象上：


```python
from pandas.tseries.offsets import Day,MonthEnd
now = datetime(2011, 11, 17)
print(now+3*Day())
# Timestamp('2011-11-20 00:00:00')
```

如果加的是锚点偏移量（比如`MonthEnd`），第一次增量会将原日期向前滚动到符合频率规则的下一个日期：


```python
print(now+MonthEnd())   # 日期将滚动到本月的最后一天
# Timestamp('2011-11-30 00:00:00')

print(now+MonthEnd(2))   # 日期将滚动到下个月的最后一天
# Timestamp('2011-12-31 00:00:00')
```

锚定偏置可以使用`rollforward`和`rollback`分别显式的向日期前后“滚动”


```python
### 首先定义偏置类型,例如每月最后一天
offset=MonthEnd()
### 对指定时间now(2019-11-15)进行向前滚动
print(offset.rollforward(now))
# Timestamp('2011-11-30 00:00:00')
print(offset.rollback(now))
# Timestamp('2011-10-31 00:00:00')
```

日期偏移量还有一个巧妙的用法，即结合`groupby`使用这两个“滚动”方法：


```python
ts = pd.Series(np.random.randn(20),
               index=pd.date_range('1/15/2000', periods=20, freq='4d'))
print(ts)
# 2000-01-15   -0.295329
# 2000-01-19    1.539478
# 2000-01-23   -1.034012
# 2000-01-27    1.102609
# 2000-01-31   -0.082710
# 2000-02-04    1.397644
# 2000-02-08    0.217985
# 2000-02-12   -0.254538
# 2000-02-16   -0.490485
# 2000-02-20   -1.606192
# 2000-02-24   -0.250439
# 2000-02-28   -0.151218
# 2000-03-03    0.166420
# 2000-03-07   -0.718974
# 2000-03-11   -0.823032
# 2000-03-15    0.477885
# 2000-03-19   -0.573430
# 2000-03-23    0.373544
# 2000-03-27    0.606128
# 2000-03-31    0.483893
# Freq: 4D, dtype: float64

print(ts.groupby(offset.rollforward).mean())
# 2000-01-31   -0.173427
# 2000-02-29    0.341669
# 2000-03-31    0.019533
# dtype: float64
```

当然，更简单、更快速地实现该功能的办法是使用`resample`

```python
print(ts.resample('M').mean())
# 2000-01-31   -0.173427
# 2000-02-29    0.341669
# 2000-03-31    0.019533
# Freq: M, dtype: float64
```

## 11.4 时区处理

好像不太常用，用到的时候再学 P320

## 11.5 时间区间和区间算术

-   ***TimeStamp* （时刻数据）**代表时间点，是从Python标准库的`datetime`类继承过来的，表示时间轴上的一个时刻。
-   ***Period* （时期对象）**代表时间段，如某年、某月、某日、某小时等，时间的长短由`freq`决定。

时间区间表示的是时间范围，pandas中Period类表示的正是这种数据类型


```python
p = pd.Period(2007, freq='A-DEC')
print(p)
# Period('2007', 'A-DEC')
```

上述`Period`对象表示的是从2019年1月1日到2019年12月31日的时间段。

只需对`Period`对象加上或减去一个整数即可达到根据其频率进行位移的效果：

```python
print(p + 5)
# Period('2012', 'A-DEC')

print(p - 2)
# Period('2005', 'A-DEC')
```

如果两个`Period`对象拥有相同的频率，则它们的差就是它们之间的单位数量：

```python
print(pd.Period('2014', freq='A-DEC') - p)
# 7
```

使用`period_range`函数可以构造规则区间序列：


```python
rng = pd.period_range('2000-01-01', '2000-06-30', freq='M')
print(rng)
# PeriodIndex(['2000-01', '2000-02', '2000-03', '2000-04', '2000-05', '2000-06'], dtype='period[M]', freq='M')
```

`PeriodIndex`类保存了一组`Period`，它可以在任何pandas数据结构中被用作轴索引：

```python
print(pd.Series(np.random.randn(6), index=rng)
# 2000-01   -0.514551
# 2000-02   -0.559782
# 2000-03   -0.783408
# 2000-04   -1.797685
# 2000-05   -0.172670
# 2000-06    0.680215
# Freq: M, dtype: float64
```

如果你有一个字符串数组，你也可以使用PeriodIndex类：

```python
values = ['2001Q3', '2002Q2', '2003Q1']
index = pd.PeriodIndex(values, freq='Q-DEC')
print(index)
# PeriodIndex(['2001Q3', '2002Q2', '2003Q1'], dtype='period[Q-DEC]', freq='Q-DEC')
```

### 11.5.1 区间频率转换

`Period`和`PeriodIndex`对象都可以通过其`asfreq`方法被转换成别的频率。

```python
p = pd.Period('2007', freq='A-DEC')
print(p)
# Period('2007', 'A-DEC')

print(p.asfreq('M', how='start'))  #起始点标注
# Period('2007-01', 'M')

print(p.asfreq('M', how='end'))  #终止点标注
# Period('2007-12', 'M')
```

<img src="C:\Users\admin\Desktop\Python_for_Data_Analysis_Wes_McKinney--master\assets\图11-1 Period频率转换示例.png" alt="图11-1 Period频率转换示例" style="zoom:50%;" />



你可以将`Period('2007','A-DEC')`看做一个被划分为多个月度时期的时间段中的游标。

```python
p = pd.Period('2007', freq='A-JUN')  #以六月为一年的终止

print(p)
# Period('2007', 'A-JUN')

print(p.asfreq('M', 'start'))
# Period('2006-07', 'M')

print(p.asfreq('M', 'end'))
# Period('2007-06', 'M')
```

在将高频率转换为低频率时，父区（`superperiod`）是由子区（`subperiod`）所属的位置决定的。例如，在`A-JUN`频率中，月份“2007年8月”实际上是属于周期“2008年”的：

```python
p = pd.Period('Aug-2007', 'M')

print(p.asfreq('A-JUN')
# Period('2008', 'A-JUN')
```

完整的`PeriodIndex`或`TimeSeries`的频率转换方式也是如此：

```python
rng = pd.period_range('2006', '2009', freq='A-DEC')
ts = pd.Series(np.random.randn(len(rng)), index=rng)
print(ts)
# 2006    1.607578
# 2007    0.200381
# 2008   -0.834068
# 2009   -0.302988
# Freq: A-DEC, dtype: float64

print(ts.asfreq('M', how='start'))
# 2006-01    1.607578
# 2007-01    0.200381
# 2008-01   -0.834068
# 2009-01   -0.302988
# Freq: M, dtype: float64
```

这里，根据年度时期的第一个月，每年的时期被取代为每月的时期。如果我们想要每年的最后一个工作日，我们可以使用`“B”`频率，并指明想要该时期的末尾：

```python
print(ts.asfreq('B', how='end'))
# 2006-12-29    1.607578
# 2007-12-31    0.200381
# 2008-12-31   -0.834068
# 2009-12-31   -0.302988
# Freq: B, dtype: float64
```

### 11.5.2 季度区间频率

季度型数据在会计、金融等领域中很常见。许多季度型数据都会涉及“财年末”的概念，通常是一年12个月中某月的最后一个日历日或工作日。就这一点来说，时期"2012Q4"根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC：

```python
p = pd.Period('2012Q4', freq='Q-JAN')

print(p)
# Period('2012Q4', 'Q-JAN')
```

在以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）。图11-2对此进行了说明：

```python
print(p.asfreq('D', 'start'))
# Period('2011-11-01', 'D')

print(p.asfreq('D', 'end'))
# Period('2012-01-31', 'D')
```

<img src="assets\图11.2 不同季度型频率之间的转换.png" alt="图11.2 不同季度型频率之间的转换" style="zoom:50%;" />

因此，Period之间的算术运算会非常简单。例如，要获取该季度倒数第二个工作日下午4点的时间戳，你可以这样：

```python
p4pm = (p.asfreq('B', 'e') - 1).asfreq('T', 's') + 16 * 60

print(p4pm)
# Period('2012-01-30 16:00', 'T')

print(p4pm.to_timestamp())
# Timestamp('2012-01-30 16:00:00')
```

period_range可用于生成季度型范围。季度型范围的算术运算也跟上面是一样的：

```python
rng = pd.period_range('2011Q3', '2012Q4', freq='Q-JAN')
ts = pd.Series(np.arange(len(rng)), index=rng)

print(ts)
# 2011Q3    0
# 2011Q4    1
# 2012Q1    2
# 2012Q2    3
# 2012Q3    4
# 2012Q4    5
# Freq: Q-JAN, dtype: int64

new_rng = (rng.asfreq('B', 'e') - 1).asfreq('T', 's') + 16 * 60
ts.index = new_rng.to_timestamp()

print(ts)
# 2010-10-28 16:00:00    0
# 2011-01-28 16:00:00    1
# 2011-04-28 16:00:00    2
# 2011-07-28 16:00:00    3
# 2011-10-28 16:00:00    4
# 2012-01-30 16:00:00    5
# dtype: int64
```

### 11.5.3 将`Timestamp`转换为`Period`（及其逆过程）

通过使用to_period方法，可以将由时间戳索引的Series和DataFrame对象转换为以时期索引：

```python
rng = pd.date_range('2000-01-01', periods=3, freq='M')
ts = pd.Series(np.random.randn(3), index=rng)

print(ts)
# 2000-01-31    1.663261
# 2000-02-29   -0.996206
# 2000-03-31    1.521760
# Freq: M, dtype: float64

pts = ts.to_period()

print(pts)
# 2000-01    1.663261
# 2000-02   -0.996206
# 2000-03    1.521760
# Freq: M, dtype: float64
```

由于时期指的是非重叠时间区间，因此对于给定的频率，一个时间戳只能属于一个时期。新PeriodIndex的频率默认是从时间戳推断而来的，你也可以指定任何别的频率。结果中允许存在重复时期：

```python
rng = pd.date_range('1/29/2000', periods=6, freq='D')
ts2 = pd.Series(np.random.randn(6), index=rng)

print(ts2)
# 2000-01-29    0.244175
# 2000-01-30    0.423331
# 2000-01-31   -0.654040
# 2000-02-01    2.089154
# 2000-02-02   -0.060220
# 2000-02-03   -0.167933
# Freq: D, dtype: float64

print(ts2.to_period('M'))
# 2000-01    0.244175
# 2000-01    0.423331
# 2000-01   -0.654040
# 2000-02    2.089154
# 2000-02   -0.060220
# 2000-02   -0.167933
# Freq: M, dtype: float64
```

要转换回时间戳，使用`to_timestamp`即可：

```python
pts = ts2.to_period()

print(pts)
# 2000-01-29    0.244175
# 2000-01-30    0.423331
# 2000-01-31   -0.654040
# 2000-02-01    2.089154
# 2000-02-02   -0.060220
# 2000-02-03   -0.167933
# Freq: D, dtype: float64

print(pts.to_timestamp(how='end'))
# 2000-01-29    0.244175
# 2000-01-30    0.423331
# 2000-01-31   -0.654040
# 2000-02-01    2.089154
# 2000-02-02   -0.060220
# 2000-02-03   -0.167933
# Freq: D, dtype: float64
```

### 11.5.4 通过数组创建`PeriodIndex`

固定频率的数据集通常会将时间信息分开存放在多个列中。例如，在下面这个宏观经济数据集中，年度和季度就分别存放在不同的列中：

```python
data = pd.read_csv('examples/macrodata.csv')

print(data.head(5))
#      year  quarter   realgdp  realcons  realinv  realgovt  realdpi    cpi  \
# 0  1959.0      1.0  2710.349    1707.4  286.898   470.045   1886.9  28.98   
# 1  1959.0      2.0  2778.801    1733.7  310.859   481.301   1919.7  29.15   
# 2  1959.0      3.0  2775.488    1751.8  289.226   491.260   1916.4  29.35   
# 3  1959.0      4.0  2785.204    1753.7  299.356   484.052   1931.3  29.37   
# 4  1960.0      1.0  2847.699    1770.5  331.722   462.199   1955.5  29.54   
#       m1  tbilrate  unemp      pop  infl  realint  
# 0  139.7      2.82    5.8  177.146  0.00     0.00  
# 1  141.7      3.08    5.1  177.830  2.34     0.74  
# 2  140.5      3.82    5.3  178.657  2.74     1.09  
# 3  140.0      4.33    5.6  179.386  0.27     4.06  
# 4  139.6      3.50    5.2  180.007  2.31     1.19  

print(data.year)
# 0      1959.0
# 1      1959.0
# 2      1959.0
# 3      1959.0
# 4      1960.0
# 5      1960.0
# 6      1960.0
# 7      1960.0
# 8      1961.0
# 9      1961.0
#         ...  
# 193    2007.0
# 194    2007.0
# 195    2007.0
# 196    2008.0
# 197    2008.0
# 198    2008.0
# 199    2008.0
# 200    2009.0
# 201    2009.0
# 202    2009.0
Name: year, Length: 203, dtype: float64

print(data.quarter)
# 0      1.0
# 1      2.0
# 2      3.0
# 3      4.0
# 4      1.0
# 5      2.0
# 6      3.0
# 7      4.0
# 8      1.0
# 9      2.0
#       ... 
# 193    2.0
# 194    3.0
# 195    4.0
# 196    1.0
# 197    2.0
# 198    3.0
# 199    4.0
# 200    1.0
# 201    2.0
# 202    3.0
# Name: quarter, Length: 203, dtype: float64
```

通过将这些数组以及一个频率传入PeriodIndex，就可以将它们合并成DataFrame的一个索引：

```python
index = pd.PeriodIndex(year=data.year, quarter=data.quarter,freq='Q-DEC')
print(index) 
# PeriodIndex(['1959Q1', '1959Q2', '1959Q3', '1959Q4', '1960Q1', '1960Q2',
#              '1960Q3', '1960Q4', '1961Q1', '1961Q2',
#              ...
#              '2007Q2', '2007Q3', '2007Q4', '2008Q1', '2008Q2', '2008Q3',
#              '2008Q4', '2009Q1', '2009Q2', '2009Q3'],
#             dtype='period[Q-DEC]', length=203, freq='Q-DEC')

data.index = index

print(data.infl)
# 1959Q1    0.00
# 1959Q2    2.34
# 1959Q3    2.74
# 1959Q4    0.27
# 1960Q1    2.31
# 1960Q2    0.14
# 1960Q3    2.70
# 1960Q4    1.21
# 1961Q1   -0.40
# 1961Q2    1.47
#           ... 
# 2007Q2    2.75
# 2007Q3    3.45
# 2007Q4    6.38
# 2008Q1    2.82
# 2008Q2    8.53
# 2008Q3   -3.16
# 2008Q4   -8.79
# 2009Q1    0.94
# 2009Q2    3.37
# 2009Q3    3.56
# Freq: Q-DEC, Name: infl, Length: 203, dtype: float64
```

## 11.6 重采样及频率转换

重采样（resampling）指的是将时间序列从一个频率转换到另一个频率的处理过程。将高频率数据聚合到低频率称为降采样（downsampling），而将低频率数据转换到高频率则称为升采样（upsampling）。并不是所有的重采样都能被划分到这两个大类中。例如，将W-WED（每周三）转换为W-FRI既不是降采样也不是升采样。

pandas对象都带有一个resample方法，它是各种频率转换工作的主力函数。resample有一个类似于groupby的API，调用resample可以分组数据，然后会调用一个聚合函数：

```python
rng = pd.date_range('2000-01-01', periods=100, freq='D')
ts = pd.Series(np.random.randn(len(rng)), index=rng)

print(ts)
# 2000-01-01    0.631634
# 2000-01-02   -1.594313
# 2000-01-03   -1.519937
# 2000-01-04    1.108752
# 2000-01-05    1.255853
# 2000-01-06   -0.024330
# 2000-01-07   -2.047939
# 2000-01-08   -0.272657
# 2000-01-09   -1.692615
# 2000-01-10    1.423830
#                 ...   
# 2000-03-31   -0.007852
# 2000-04-01   -1.638806
# 2000-04-02    1.401227
# 2000-04-03    1.758539
# 2000-04-04    0.628932
# 2000-04-05   -0.423776
# 2000-04-06    0.789740
# 2000-04-07    0.937568
# 2000-04-08   -2.253294
# 2000-04-09   -1.772919
# Freq: D, Length: 100, dtype: float64

print(ts.resample('M').mean())
# 2000-01-31   -0.165893
# 2000-02-29    0.078606
# 2000-03-31    0.223811
# 2000-04-30   -0.063643
# Freq: M, dtype: float64

print(ts.resample('M', kind='period').mean())
# 2000-01   -0.165893
# 2000-02    0.078606
# 2000-03    0.223811
# 2000-04   -0.063643
# Freq: M, dtype: float64
```

resample是一个灵活高效的方法，可用于处理非常大的时间序列。我将通过一系列的示例说明其用法。表11-5总结它的一些选项。

表11-5 resample方法的参数
![](https://upload-images.jianshu.io/upload_images/7178691-b40a57086c904e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



## 降采样

将数据聚合到规律的低频率是一件非常普通的时间序列处理任务。待聚合的数据不必拥有固定的频率，期望的频率会自动定义聚合的面元边界，这些面元用于将时间序列拆分为多个片段。例如，要转换到月度频率（'M'或'BM'），数据需要被划分到多个单月时间段中。各时间段都是半开放的。一个数据点只能属于一个时间段，所有时间段的并集必须能组成整个时间帧。在用resample对数据进行降采样时，需要考虑两样东西：

- 各区间哪边是闭合的。
- 如何标记各个聚合面元，用区间的开头还是末尾。

为了说明，我们来看一些“1分钟”数据：

```python
rng = pd.date_range('2000-01-01', periods=12, freq='T')

ts = pd.Series(np.arange(12), index=rng)

print(ts)
# 2000-01-01 00:00:00     0
# 2000-01-01 00:01:00     1
# 2000-01-01 00:02:00     2
# 2000-01-01 00:03:00     3
# 2000-01-01 00:04:00     4
# 2000-01-01 00:05:00     5
# 2000-01-01 00:06:00     6
# 2000-01-01 00:07:00     7
# 2000-01-01 00:08:00     8
# 2000-01-01 00:09:00     9
# 2000-01-01 00:10:00    10
# 2000-01-01 00:11:00    11
# Freq: T, dtype: int64
```

假设你想要通过求和的方式将这些数据聚合到“5分钟”块中：

```python
print(ts.resample('5min', closed='right').sum())
# 1999-12-31 23:55:00     0
# 2000-01-01 00:00:00    15
# 2000-01-01 00:05:00    40
# 2000-01-01 00:10:00    11
# Freq: 5T, dtype: int64
```

传入的频率将会以“5分钟”的增量定义面元边界。默认情况下，面元的右边界是包含的，因此00:00到00:05的区间中是包含00:05的。传入closed='left'会让区间以左边界闭合：

```python
print(ts.resample('5min', closed='right').sum())
# 1999-12-31 23:55:00     0
# 2000-01-01 00:00:00    15
# 2000-01-01 00:05:00    40
# 2000-01-01 00:10:00    11
# Freq: 5T, dtype: int64
```

如你所见，最终的时间序列是以各面元右边界的时间戳进行标记的。传入label='right'即可用面元的邮编界对其进行标记：

```python
print(ts.resample('5min', closed='right', label='right').sum())
# 2000-01-01 00:00:00     0
# 2000-01-01 00:05:00    15
# 2000-01-01 00:10:00    40
# 2000-01-01 00:15:00    11
# Freq: 5T, dtype: int64
```

图11-3说明了“1分钟”数据被转换为“5分钟”数据的处理过程。

![图11-3 各种closed、label约定的“5分钟”重采样演示](http://upload-images.jianshu.io/upload_images/7178691-7a77f47844f2ee8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

最后，你可能希望对结果索引做一些位移，比如从右边界减去一秒以便更容易明白该时间戳到底表示的是哪个区间。只需通过loffset设置一个字符串或日期偏移量即可实现这个目的：

```python
print(ts.resample('5min', closed='right',label='right', loffset='-1s').sum())
# 1999-12-31 23:59:59     0
# 2000-01-01 00:04:59    15

print(ts.resample('5min', closed='right',label='right', loffset='-1s').sum())
# 1999-12-31 23:59:59     0
# 2000-01-01 00:04:59    15
```

此外，也可以通过调用结果对象的shift方法来实现该目的，这样就不需要设置loffset了。

##OHLC重采样

金融领域中有一种无所不在的时间序列聚合方式，即计算各面元的四个值：第一个值（open，开盘）、最后一个值（close，收盘）、最大值（high，最高）以及最小值（low，最低）。传入how='ohlc'即可得到一个含有这四种聚合值的DataFrame。整个过程很高效，只需一次扫描即可计算出结果：

```python
print(ts.resample('5min').ohlc())
#                      open  high  low  close
# 2000-01-01 00:00:00     0     4    0      4
# 2000-01-01 00:05:00     5     9    5      9
# 2000-01-01 00:10:00    10    11   10     11
```

##升采样和插值

在将数据从低频率转换到高频率时，就不需要聚合了。我们来看一个带有一些周型数据的DataFrame：

```python
frame = pd.DataFrame(np.random.randn(2, 4),index=pd.date_range('1/1/2000', periods=2,freq='W-WED'),columns=['Colorado', 'Texas', 'New York', 'Ohio'])
print(frame)
#             Colorado     Texas  New York      Ohio
# 2000-01-05 -0.896431  0.677263  0.036503  0.087102
# 2000-01-12 -0.046662  0.927238  0.482284 -0.867130
```

当你对这个数据进行聚合，每组只有一个值，这样就会引入缺失值。我们使用asfreq方法转换成高频，不经过聚合：

```python
df_daily = frame.resample('D').asfreq()
print(df_daily)
#             Colorado     Texas  New York      Ohio
# 2000-01-05 -0.896431  0.677263  0.036503  0.087102
# 2000-01-06       NaN       NaN       NaN       NaN
# 2000-01-07       NaN       NaN       NaN       NaN
# 2000-01-08       NaN       NaN       NaN       NaN
# 2000-01-09       NaN       NaN       NaN       NaN
# 2000-01-10       NaN       NaN       NaN       NaN
# 2000-01-11       NaN       NaN       NaN       NaN
# 2000-01-12 -0.046662  0.927238  0.482284 -0.867130
```

假设你想要用前面的周型值填充“非星期三”。resampling的填充和插值方式跟fillna和reindex的一样：

```python
print(frame.resample('D').ffill())
#             Colorado     Texas  New York      Ohio
# 2000-01-05 -0.896431  0.677263  0.036503  0.087102
# 2000-01-06 -0.896431  0.677263  0.036503  0.087102
# 2000-01-07 -0.896431  0.677263  0.036503  0.087102
# 2000-01-08 -0.896431  0.677263  0.036503  0.087102
# 2000-01-09 -0.896431  0.677263  0.036503  0.087102
# 2000-01-10 -0.896431  0.677263  0.036503  0.087102
# 2000-01-11 -0.896431  0.677263  0.036503  0.087102
# 2000-01-12 -0.046662  0.927238  0.482284 -0.867130
```

同样，这里也可以只填充指定的时期数（目的是限制前面的观测值的持续使用距离）：

```python
print(frame.resample('D').ffill(limit=2))
#             Colorado     Texas  New York      Ohio
# 2000-01-05 -0.896431  0.677263  0.036503  0.087102
# 2000-01-06 -0.896431  0.677263  0.036503  0.087102
# 2000-01-07 -0.896431  0.677263  0.036503  0.087102
# 2000-01-08       NaN       NaN       NaN       NaN
# 2000-01-09       NaN       NaN       NaN       NaN
# 2000-01-10       NaN       NaN       NaN       NaN
# 2000-01-11       NaN       NaN       NaN       NaN
# 2000-01-12 -0.046662  0.927238  0.482284 -0.867130
```

注意，新的日期索引完全没必要跟旧的重叠：

```python
print(frame.resample('W-THU').ffill())
#             Colorado     Texas  New York      Ohio
# 2000-01-06 -0.896431  0.677263  0.036503  0.087102
# 2000-01-13 -0.046662  0.927238  0.482284 -0.867130
```

## 通过时期进行重采样

对那些使用时期索引的数据进行重采样与时间戳很像：

```python
frame = pd.DataFrame(np.random.randn(24, 4),index=pd.period_range('1-2000', '12-2001',freq='M'), columns=['Colorado', 'Texas', 'New York', 'Ohio'])

print(frame[:5])
#          Colorado     Texas  New York      Ohio
# 2000-01  0.493841 -0.155434  1.397286  1.507055
# 2000-02 -1.179442  0.443171  1.395676 -0.529658
# 2000-03  0.787358  0.248845  0.743239  1.267746
# 2000-04  1.302395 -0.272154 -0.051532 -0.467740
# 2000-05 -1.040816  0.426419  0.312945 -1.115689

annual_frame = frame.resample('A-DEC').mean()
print(annual_frame)
#       Colorado     Texas  New York      Ohio
# 2000  0.556703  0.016631  0.111873 -0.027445
# 2001  0.046303  0.163344  0.251503 -0.157276
```

升采样要稍微麻烦一些，因为你必须决定在新频率中各区间的哪端用于放置原来的值，就像asfreq方法那样。convention参数默认为'start'，也可设置为'end'：

```python
# Q-DEC: Quarterly, year ending in December
print(annual_frame.resample('Q-DEC').ffill())
#         Colorado     Texas  New York      Ohio
# 2000Q1  0.556703  0.016631  0.111873 -0.027445
# 2000Q2  0.556703  0.016631  0.111873 -0.027445
# 2000Q3  0.556703  0.016631  0.111873 -0.027445
# 2000Q4  0.556703  0.016631  0.111873 -0.027445
# 2001Q1  0.046303  0.163344  0.251503 -0.157276
# 2001Q2  0.046303  0.163344  0.251503 -0.157276
# 2001Q3  0.046303  0.163344  0.251503 -0.157276
# 2001Q4  0.046303  0.163344  0.251503 -0.157276

print(annual_frame.resample('Q-DEC', convention='end').ffill())
#         Colorado     Texas  New York      Ohio
# 2000Q4  0.556703  0.016631  0.111873 -0.027445
# 2001Q1  0.556703  0.016631  0.111873 -0.027445
# 2001Q2  0.556703  0.016631  0.111873 -0.027445
# 2001Q3  0.556703  0.016631  0.111873 -0.027445
# 2001Q4  0.046303  0.163344  0.251503 -0.157276
```

由于时期指的是时间区间，所以升采样和降采样的规则就比较严格：

- 在降采样中，目标频率必须是源频率的子时期（subperiod）。
- 在升采样中，目标频率必须是源频率的超时期（superperiod）。

如果不满足这些条件，就会引发异常。这主要影响的是按季、年、周计算的频率。例如，由Q-MAR定义的时间区间只能升采样为A-MAR、A-JUN、A-SEP、A-DEC等：

```python
print(annual_frame.resample('Q-MAR').ffill())
#         Colorado     Texas  New York      Ohio
# 2000Q4  0.556703  0.016631  0.111873 -0.027445
# 2001Q1  0.556703  0.016631  0.111873 -0.027445
# 2001Q2  0.556703  0.016631  0.111873 -0.027445
# 2001Q3  0.556703  0.016631  0.111873 -0.027445
# 2001Q4  0.046303  0.163344  0.251503 -0.157276
# 2002Q1  0.046303  0.163344  0.251503 -0.157276
# 2002Q2  0.046303  0.163344  0.251503 -0.157276
# 2002Q3  0.046303  0.163344  0.251503 -0.157276
```

## 11.7 移动窗口函数

好像不太常用，用到的时候再学 P339